# Работа с грешки

Можете да използвате грешките, като използвате какъвто и да е тип, който наследява Error протокола.

    enum EpisodeMarkError: Error {
    	case unexistingEpisode
		case unexistingShow
	}

Функциите могат да връщат грешки, но трябва да бъде отразено в кода. Това става чрез използването на запазената дума throws в дефиницията на функция. Ако върнете грешка, функцията спира изпълнението на изразите в нея, а кодът, който е извикал функцията, трябва да се справи с грешката.

	let tvShows: [String:Int] = ["The Bold and the Beautiful" : 7657, "Vikings" : 50, "Black Sails" : 38]

    func mark(asWatched show: String, episode: Int) throws -> String {
		guard let episodeCount = tvShows[show] else {
			throw EpisodeMarkError.unexistingShow
		}
 
		if episodeCount < episode {
			throw EpisodeMarkError.unexistingEpisode
		}

		return "Marked as watched"
	}

В примера маркираме епизод като изгледан, ако сериала съществува в нашия лист и епизода вече е излъчен. Проверката дали сериала съществува е усеществена чрез използването на guard оператор.

guard оператора, подобно на if оператора, изпълнява изрази в зависимост от булева променлива. Чрез използването на guard оператора, задължавате условието да бъде true, за да може да продължиизпълнението на изразите във вашият код. За разлика от if оператора, guard оператора винаги има else. Изразите в else-a биват изпълнени, само ако условието е false.
Ако условието на guard оператора е изпълнено, изпълнението на кода продължава след затварящата скоба (}) на оператора. Всички променливи или константи, дефинирани в условието, са достъпни в останалата част от блока от изрази, в който оператора е бил дефиниран.
Ако условието на guard оператора не е изпълнено, кодът в else-a бива изпълнен. Той **трябва** да прехвърли контрола за да излезе от блока изрази, в който guard опеаратора е дефиниран. Това става чрез използването на операторите: return, break, continue или както в примера по-горе - throw.

-----

Има няколко начина да се справите с хвърлените грешки. Единият от начините е да използвате do-catch. В do блока можете да маркирате код, който връща грешки, като напишете try пред него. А в catch блока ще можете да прихванете, ако маркираният код хвърли някаква грешка. В carch-ът грешката ще бъде именована автоматично като error, освен ако не й дадем друго име.

	do {
		let response = try mark(asWatched: "Vikings", episode: 31)
		print(response)
	} catch {
		print(error)
	}

Можете да добавите няколко catch блока, които да се справят със специфични грешки. Това става, като напишете модел за проверка след catch-a, както при case в switch оператора.

	do {
		let response = try mark(asWatched: "Vikings", episode: 31)
		print(response)
	} catch EpisodeMarkError.unexistingShow {
		print("We will try to add this show to our list.")
	} catch let markError as EpisodeMarkError {
		print("Mark error: \(markError)")
	} catch {
		print(error)
	}

Друг начин за работа с грешки е да използвате try? за да третирате резултата като Optional. Ако функцията върне грешка, тя ще бъде игнорирана, а резулатата ще бъде nil. Ако ли не, резултатът ще бъде Optional съдържащ резултата от функцията.

	let successfulMark = try? mark(asWatched: "Vikings", episode: 43)
	let unsuccessfulMark = try? mark(asWatched: "Vikings", episode: 51)


# Assert

В някои ситуации не е възможно изпълнението на кода да продължи, ако определено условие не е изпълнено. В тези ситуации можете да излзвате assert. Използването му ще прекрати действието на кода Ви и ще Ви даде възможност да разберете причината за липсващата или невалидна стойност.

Assert-a заявява, че дадено условие изпълнено (true). Това бива проверявано по време на изпълнението на кода. Можете да използвате assert за да проверите дали важно, за вашият код, условие е изпълнено преди да продължите напред. Ако условието е вярно (true) изпълнението продължава, ако ли не - изпълнението прекъсва, а вашата програма е прекратена.
Ако assert бъде задействан, по време на изпълнение през среда като Xcode, можете да видите точно къде е станал проблема, а ако сте добавили допълнителна информация, към дефиницията на assert-a, тя ще Ви бъде предоставена.

	let soapOpera = "The Bold and the Beautiful"
	assert((tvShows[soapOpera] != nil), "We should add \"\(soapOpera)\"")
	print("\(soapOpera) is a soap opera.")

В този пример изпълнението ще продължи само, ако tvShows[soapOpera] != nil ни върне true, ако подадената soapOpera съществува в листа ни със сериали. Ако в tvShows нямаме сериал с името подадено в soapOpera, програмата ще бъде прекратена
**Важно!** Използвайте assert, когато условие има потенциала да бъде грешно, но за да продължи програмата е **необходимо** то да е вятно.

